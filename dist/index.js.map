{"version":3,"sources":["../src/utils/index.ts","../src/operations/chat.ts","../src/operations/getConversation.ts","../src/operations/listConversations.ts","../src/operations/getConversationEventEmitter.ts","../src/operations/sendMessage.ts","../src/operations/updateConversation.ts","../src/index.ts"],"names":["EventEmitter","match","_a","_b","event","axios"],"mappings":"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","file":"index.js","sourcesContent":["import { match } from \"ts-pattern\"\nimport { EventSource } from \"eventsource\"\nimport { EventEmitter } from \"events\"\n\nexport type CommonStreamData = {\n  messageId: number\n}\n\nexport type StreamDocumentChunk = {\n  id: number,\n  content: string\n}\n\nexport type StreamDocument = {\n  id: number,\n  name: string,\n  chunks: StreamDocumentChunk[]\n}\n\nexport type ErrorStreamData = CommonStreamData & {\n  type: \"ERROR\",\n  code: string,\n  message: string\n}\n\nexport type EndStreamData = CommonStreamData & {\n  type: \"END\",\n  iteration: number,\n  data: {\n    content: string,\n    documents: StreamDocument[]\n  } | null,\n  error: {\n    code: string,\n    message: string\n  } | null\n}\n\nexport type ChunkStreamData = CommonStreamData & {\n  type: \"CHUNK\",\n  content: string,\n  index: number,\n  iteration: number,\n}\n\nexport type ChunkAggregateStreamData = CommonStreamData & {\n  type: \"CHUNK_AGGREGATE\",\n  fromIndex: number,\n  toIndex: number,\n  content: string,\n  iteration: number,\n}\n\nexport type ToolCallStartStreamData = CommonStreamData & {\n  type: \"TOOL_CALL_START\",\n  iteration: number,\n  toolCallIndex: number,\n  tool: {\n    id: number,\n    name: string\n  }\n}\n\nexport type ToolCallEndStreamData = CommonStreamData & {\n  type: \"TOOL_CALL_END\",\n  iteration: number,\n  toolCallIndex: number,\n}\n\nexport type StreamData = (\n  ErrorStreamData |\n  EndStreamData |\n  ChunkStreamData |\n  ChunkAggregateStreamData |\n  ToolCallStartStreamData |\n  ToolCallEndStreamData\n)\n\nexport type IterableChunkData = {\n  content: string,\n  index: number,\n  iteration: number,\n}\n\nexport type ConversationEventEmitterMap = {\n  data: [StreamData],\n  chunk: [ChunkStreamData],\n  \"chunk-aggregate\": [ChunkAggregateStreamData],\n  end: [EndStreamData],\n  error: [unknown],\n  \"tool-call-start\": [ToolCallStartStreamData],\n  \"tool-call-end\": [ToolCallEndStreamData],\n}\n\nexport type ConversationEventEmitter = EventEmitter<ConversationEventEmitterMap>\n\nexport type CompletionAsyncIterable = AsyncIterable<IterableChunkData> & {\n  messageId: number,\n  documents: StreamDocument[] | null,\n  error: {\n    code: string,\n    message: string\n  } | null,\n  partial: string,\n  _chunks: { content: string, index: number }[],\n  toolCalls: {\n    iteration: number,\n    toolCallIndex: number,\n    tool: {\n      id: number,\n      name: string\n    },\n    finished: boolean,\n  }[],\n  emitter: ConversationEventEmitter,\n  complete: AsyncIterable<StreamData>\n}\n\nexport const parseEventMessage = (event: MessageEvent) => {\n  try {\n    if (event.type === \"message\" && event.data) {\n      const data = JSON.parse(event.data) as StreamData\n      return data\n    }\n  } catch (_) { }\n\n  return null\n}\n\nexport const conversationEventSourceToEventEmitter = (eventSource: EventSource): ConversationEventEmitter => {\n  const emitter = new EventEmitter<ConversationEventEmitterMap>()\n\n  const processMessage = (event: StreamData) => {\n    emitter.emit(\"data\", event)\n\n    match(event)\n      .with({ type: \"ERROR\" }, (value) => emitter.emit(\"error\", value))\n      .with({ type: \"END\" }, (value) => emitter.emit(\"end\", value))\n      .with({ type: \"CHUNK\" }, (value) => emitter.emit(\"chunk\", value))\n      .with({ type: \"CHUNK_AGGREGATE\" }, (value) => emitter.emit(\"chunk-aggregate\", value))\n      .with({ type: \"TOOL_CALL_START\" }, (value) => emitter.emit(\"tool-call-start\", value))\n      .with({ type: \"TOOL_CALL_END\" }, (value) => emitter.emit(\"tool-call-end\", value))\n      .exhaustive()\n  }\n\n  eventSource.onmessage = (event: MessageEvent) => {\n    const data = parseEventMessage(event)\n\n    if (data) {\n      processMessage(data)\n    }\n  }\n\n  eventSource.onerror = (error: unknown) => {\n    emitter.emit(\"error\", error)\n  }\n\n  return emitter\n}\n\n// type Queue<T> = {\n//   waitForChunkResolveFunction: any,\n//   done: boolean,\n//   queue: T[],\n//   waitForChunk: () => Promise<void>,\n// }\n\nclass Queue<T> {\n  done: boolean\n  queue: T[]\n  waitForChunkResolveFunction: any\n\n  constructor() {\n    this.done = false\n    this.queue = []\n    this.waitForChunkResolveFunction = undefined\n  }\n\n  waitForChunk() {\n    return new Promise((resolve) => this.waitForChunkResolveFunction = resolve)\n  }\n}\n\n// const getQueue = <T>() => {\n//   const out: Omit<Queue<T>, \"waitForChunk\"> = {\n//     done: false,\n//     queue: [],\n//     waitForChunkResolveFunction: undefined,\n//   }\n\n//   return {\n//     ...out,\n//     waitForChunk: () => (\n//       new Promise((resolve) => out.waitForChunkResolveFunction = resolve)\n//     ),\n//   }\n// }\n\nexport const messageEventSourceToAsyncIterable = (\n  eventSource: EventSource,\n  messageId: number\n) => {\n  const chunksQueue = new Queue<IterableChunkData>()\n  const completeQueue = new Queue<StreamData>()\n\n  function end() {\n    chunksQueue.done = true\n    completeQueue.done = true\n\n    chunksQueue.waitForChunkResolveFunction?.()\n    chunksQueue.waitForChunkResolveFunction = undefined\n\n    completeQueue.waitForChunkResolveFunction?.()\n    completeQueue.waitForChunkResolveFunction = undefined\n\n    eventSource.close()\n  }\n\n  const parsedEmitter = conversationEventSourceToEventEmitter(eventSource)\n\n  const processMessage = (event: StreamData) => {\n    if (event.messageId !== messageId) {\n      return\n    }\n\n    completeQueue.queue.push(event)\n    completeQueue.waitForChunkResolveFunction?.()\n    completeQueue.waitForChunkResolveFunction = undefined\n\n    match(event)\n      .with({ type: \"ERROR\" }, (value) => {\n        out.error = {\n          code: value.code,\n          message: value.message\n        }\n\n        end()\n      })\n      .with({ type: \"CHUNK\" }, (event) => {\n        const value = {\n          content: event.content,\n          index: event.index,\n          iteration: event.iteration\n        }\n\n        out._chunks.push(value)\n        chunksQueue.queue.push(value)\n\n        chunksQueue.waitForChunkResolveFunction?.()\n        chunksQueue.waitForChunkResolveFunction = undefined\n      })\n      .with({ type: \"CHUNK_AGGREGATE\" }, () => { })\n      .with({ type: \"TOOL_CALL_START\" }, (event) => {\n        out.toolCalls.push({\n          iteration: event.iteration,\n          toolCallIndex: event.toolCallIndex,\n          tool: event.tool,\n          finished: false\n        })\n      })\n      .with({ type: \"TOOL_CALL_END\" }, (event) => {\n        const toolCall = out.toolCalls.find((call) => call.toolCallIndex === event.toolCallIndex)\n\n        if (toolCall) {\n          toolCall.finished = true\n        }\n      })\n      .with({ type: \"END\" }, () => end())\n      .exhaustive()\n  }\n\n  parsedEmitter.on(\"data\", (event: StreamData) => {\n    processMessage(event)\n  })\n\n  const out: CompletionAsyncIterable = {\n    messageId,\n    documents: null,\n    error: null,\n    _chunks: [],\n    toolCalls: [],\n    emitter: parsedEmitter,\n\n    get partial() {\n      return (\n        this._chunks\n          .sort((a, b) => a.index - b.index)\n          .map(chunk => chunk.content)\n          .join(\"\")\n      )\n    },\n\n    async *[Symbol.asyncIterator]() {\n      while (true) {\n        const value = chunksQueue.queue.shift()\n\n        if (value) {\n          yield value\n        } else {\n          // end() has been called. The queue is empty and no more chunks will be added\n          if (chunksQueue.done) {\n            return\n          }\n\n          // No more chunks in the queue, wait for a new chunk\n          await chunksQueue.waitForChunk()\n        }\n      }\n    },\n\n    complete: {\n      async *[Symbol.asyncIterator]() {\n        while (true) {\n          const value = completeQueue.queue.shift()\n          if (value) {\n            yield value\n          } else {\n            // end() has been called. The queue is empty and no more chunks will be added\n            if (completeQueue.done) {\n              return\n            }\n\n            // No more chunks in the queue, wait for a new chunk\n            await completeQueue.waitForChunk()\n          }\n        }\n      },\n    }\n  }\n\n  return out\n}\n\nexport type SyncResponse = {\n  messageId: number,\n  content: string,\n  documents: StreamDocument[]\n}\n\nexport const messageEventSourceToSyncResponse = async (\n  eventSource: EventSource,\n  messageId: number\n): Promise<SyncResponse> => {\n  let resolve: any\n  let reject: any\n\n  const mainPromise = new Promise<SyncResponse>((res, rej) => {\n    resolve = res\n    reject = rej\n  })\n\n  const processMessage = (event: StreamData) => {\n    if (event.messageId !== messageId) {\n      return\n    }\n\n    if (event.type === \"END\") {\n      if (event.data) {\n        resolve({\n          messageId: event.messageId,\n          content: event.data.content,\n          documents: event.data.documents\n        })\n      }\n\n      if (event.error) {\n        reject({\n          code: event.error.code,\n          message: event.error.message\n        })\n      }\n\n      reject()\n    }\n\n    if (event.type === \"ERROR\") {\n      reject({\n        code: event.code,\n        message: event.message\n      })\n    }\n  }\n\n  eventSource.onerror = (error: unknown) => {\n    reject(error)\n  }\n\n  eventSource.onmessage = (event: MessageEvent) => {\n    const data = parseEventMessage(event)\n\n    if (data) {\n      processMessage(data)\n    }\n  }\n\n  return mainPromise\n}\n","import ChatbotSDK from \"$src\"\nimport { CompletionAsyncIterable, messageEventSourceToAsyncIterable, messageEventSourceToSyncResponse, SyncResponse } from \"$utils\"\n\nexport type Request<STREAM extends boolean> = {\n  prompt: string,\n  conversationId: number,\n  stream?: STREAM\n}\n\nexport type Response<STREAM extends boolean> = STREAM extends true ? CompletionAsyncIterable : Promise<SyncResponse>\n\nexport default (sdk: ChatbotSDK) => async <STREAM extends boolean>(request: Request<STREAM>): Promise<Response<STREAM>> => {\n  const evt = await sdk._getConversationStream(request.conversationId)\n  const { messageId } = await sdk.sendMessage({ conversationId: request.conversationId, prompt: request.prompt })\n\n  if (request.stream) {\n    return messageEventSourceToAsyncIterable(evt, messageId) as Response<STREAM>\n  } else {\n    return messageEventSourceToSyncResponse(evt, messageId) as Response<STREAM>\n  }\n}\n","import ChatbotSDK from \"$src\"\nimport { Conversation } from \"$types/index\"\n\nexport type Request = {\n  conversationId: number\n}\n\nexport type Response = Conversation\n\nexport default (sdk: ChatbotSDK) => (request: Request): Promise<Response> => (\n  sdk.call({\n    method: \"get\",\n    url: `/public/conversations/${request.conversationId}`\n  })\n)\n","import ChatbotSDK from \"$src\"\nimport { ConversationListItem } from \"$types/index\"\n\nexport type Response = ConversationListItem[]\n\nexport default (sdk: ChatbotSDK) => (): Promise<Response> => (\n  sdk.call({\n    method: \"get\",\n    url: \"/public/conversations\"\n  })\n)\n","import ChatbotSDK from \"$src\"\nimport { ConversationEventEmitter, conversationEventSourceToEventEmitter } from \"$utils/index\"\n\nexport type Request = {\n  conversationId: number\n}\n\nexport type Response = ConversationEventEmitter\n\nexport default (sdk: ChatbotSDK) => async(request: Request): Promise<Response> => {\n  const evt = await sdk._getConversationStream(request.conversationId)\n  return conversationEventSourceToEventEmitter(evt)\n}\n","import ChatbotSDK from \"$src\"\n\nexport type Request = {\n  prompt: string,\n  conversationId: number\n}\n\nexport type Response = {\n  messageId: number\n}\n\nexport default (sdk: ChatbotSDK) => async (request: Request): Promise<Response> => (\n  sdk.call({\n    method: \"post\",\n    url: \"/public/messages\",\n    data: request\n  })\n)\n","import ChatbotSDK from \"$src\"\nimport { Conversation, ConversationUpdate } from \"$types/index\"\n\nexport type Request = {\n  conversationId: number\n  updates: {\n    title?: Conversation[\"title\"]\n  }\n}\n\nexport type Response = ConversationUpdate\n\nexport default (sdk: ChatbotSDK) => (request: Request): Promise<Response> => (\n  sdk.call({\n    method: \"patch\",\n    url: `/public/conversations/${request.conversationId}`,\n    data: {\n      updates: request.updates\n    }\n  })\n)\n","import axios, { Axios, AxiosRequestConfig, CreateAxiosDefaults } from \"axios\"\nimport { ChatbotSDKBaseConfig, ConversationEventSourceClass, ConversationEventSourceInstance } from \"./types\"\n\nimport chat from \"$src/operations/chat\"\nimport getConversation from \"$operations/getConversation\"\nimport listConversations from \"$operations/listConversations\"\nimport getConversationEventEmitter from \"$operations/getConversationEventEmitter\"\nimport sendMessage from \"$operations/sendMessage\"\nimport updateConversation from \"./operations/updateConversation\"\n\nexport default class ChatbotSDK {\n  axios: Axios\n\n  private EventSource: ConversationEventSourceClass\n  private authToken?: string\n  private baseURL: string\n\n  constructor(config?: ChatbotSDKBaseConfig, axiosConfig?: CreateAxiosDefaults) {\n    if (config?.EventSource) {\n      this.EventSource = config.EventSource\n    } else {\n      const EventSource = window.EventSource\n\n      if (!EventSource) {\n        throw new Error(\"EventSource is not available. Please provide an eventsource instance.\")\n      }\n\n      this.EventSource = EventSource\n    }\n\n    this.baseURL = config?.baseUrl || \"https://chatbot.hrtools.it\"\n    this.axios = axios.create({\n      baseURL: this.baseURL,\n      ...(axiosConfig || {}),\n    })\n\n    this.setAuthToken(config?.authToken)\n  }\n\n  setAuthToken(token?: string) {\n    if (token) {\n      this.axios.defaults.headers.common[\"Authorization\"] = `Bearer ${token}`\n      this.authToken = token\n    } else {\n      delete this.axios.defaults.headers.common[\"Authorization\"]\n      this.authToken = undefined\n    }\n\n    this.authToken = token\n  }\n\n  call = async <T>(request: AxiosRequestConfig): Promise<T> => {\n    try {\n      const { data } = await this.axios.request<T>(request)\n      return data\n    } catch (error) {\n      if (axios.isAxiosError(error)) {\n        const { response } = error\n\n        if (response?.data) {\n          throw response.data\n        }\n      }\n\n      throw error\n    }\n  }\n\n  chat = chat(this)\n  getConversation = getConversation(this)\n  listConversations = listConversations(this)\n  sendMessage = sendMessage(this)\n  getConversationEventEmitter = getConversationEventEmitter(this)\n  updateConversation = updateConversation(this)\n\n  _getConversationStream = async(conversationId: number): Promise<ConversationEventSourceInstance> => {\n    const url = new URL(`${this.baseURL}/public/conversations/${conversationId}/stream`)\n\n    if (this.authToken) {\n      url.searchParams.append(\"authToken\", this.authToken)\n    }\n\n    return new this.EventSource(url)\n  }\n}\n"]}